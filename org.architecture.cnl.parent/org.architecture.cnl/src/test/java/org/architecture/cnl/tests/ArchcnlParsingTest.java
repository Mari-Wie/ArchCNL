/** generated by Xtext 2.23.0 */
package org.architecture.cnl.tests;

import com.google.inject.Inject;
import org.architecture.cnl.archcnl.*;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.testing.InjectWith;
import org.eclipse.xtext.testing.XtextRunner;
import org.eclipse.xtext.testing.util.ParseHelper;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.junit.Assert;
import org.junit.Test;
import org.junit.runner.RunWith;

@RunWith(XtextRunner.class)
@InjectWith(ArchcnlInjectorProvider.class)
@SuppressWarnings("all")
public class ArchcnlParsingTest {
    @Inject private ParseHelper<Model> parseHelper;

    @Test
    public void testErrorDetected() throws Exception {
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("This is not valid ArchCNL because the syntax is not complied with.");
        _builder.newLine();
        final Model result = this.parseHelper.parse(_builder);
        Assert.assertNull(result);
    }

    @Test
    public void testEveryRule() throws Exception {
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("Every Observer must observe an Observable.");
        _builder.newLine();
        final Model result = this.parseHelper.parse(_builder);
        Assert.assertNotNull(result);
        final EList<Resource.Diagnostic> errors = result.eResource().getErrors();
        StringConcatenation _builder_1 = new StringConcatenation();
        _builder_1.append("Unexpected errors: ");
        String _join = IterableExtensions.join(errors, ", ");
        _builder_1.append(_join);
        Assert.assertTrue(_builder_1.toString(), errors.isEmpty());
        Assert.assertEquals(result.getSentence().size(), 1);
        final Sentence sentence = result.getSentence().get(0);
        EObject _ruletype = sentence.getRuletype();
        Assert.assertTrue((_ruletype instanceof MustRuleType));
    }

    @Test
    public void testEveryMustBeRule() throws Exception {
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("Every LayerAbove must be a Layer.");
        _builder.newLine();
        final Model result = this.parseHelper.parse(_builder);
        Assert.assertNotNull(result);
        final EList<Resource.Diagnostic> errors = result.eResource().getErrors();
        StringConcatenation _builder_1 = new StringConcatenation();
        _builder_1.append("Unexpected errors: ");
        String _join = IterableExtensions.join(errors, ", ");
        _builder_1.append(_join);
        Assert.assertTrue(_builder_1.toString(), errors.isEmpty());
        Assert.assertEquals(result.getSentence().size(), 1);
        final Sentence sentence = result.getSentence().get(0);
        EObject _ruletype = sentence.getRuletype();
        Assert.assertTrue((_ruletype instanceof SubConceptRuleType));
    }

    @Test
    public void testEveryCanOnlyRule() throws Exception {
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("Every LayerBelow can-only import Common.");
        _builder.newLine();
        final Model result = this.parseHelper.parse(_builder);
        Assert.assertNotNull(result);
        final EList<Resource.Diagnostic> errors = result.eResource().getErrors();
        StringConcatenation _builder_1 = new StringConcatenation();
        _builder_1.append("Unexpected errors: ");
        String _join = IterableExtensions.join(errors, ", ");
        _builder_1.append(_join);
        Assert.assertTrue(_builder_1.toString(), errors.isEmpty());
        Assert.assertEquals(result.getSentence().size(), 1);
        final Sentence sentence = result.getSentence().get(0);
        EObject _ruletype = sentence.getRuletype();
        Assert.assertTrue((_ruletype instanceof CanOnlyRuleType));
    }

    @Test
    public void testOnlyCanRule() throws Exception {
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("Only LayerAbove can use LayerBelow.");
        _builder.newLine();
        final Model result = this.parseHelper.parse(_builder);
        Assert.assertNotNull(result);
        final EList<Resource.Diagnostic> errors = result.eResource().getErrors();
        StringConcatenation _builder_1 = new StringConcatenation();
        _builder_1.append("Unexpected errors: ");
        String _join = IterableExtensions.join(errors, ", ");
        _builder_1.append(_join);
        Assert.assertTrue(_builder_1.toString(), errors.isEmpty());
        Assert.assertEquals(result.getSentence().size(), 1);
        final Sentence sentence = result.getSentence().get(0);
        EObject _ruletype = sentence.getRuletype();
        Assert.assertTrue((_ruletype instanceof OnlyCanRuleType));
    }

    @Test
    public void testConditionalRule() throws Exception {
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("If Class creates Resource, then it must destroy this Resource.");
        _builder.newLine();
        final Model result = this.parseHelper.parse(_builder);
        Assert.assertNotNull(result);
        final EList<Resource.Diagnostic> errors = result.eResource().getErrors();
        StringConcatenation _builder_1 = new StringConcatenation();
        _builder_1.append("Unexpected errors: ");
        String _join = IterableExtensions.join(errors, ", ");
        _builder_1.append(_join);
        Assert.assertTrue(_builder_1.toString(), errors.isEmpty());
        Assert.assertEquals(result.getSentence().size(), 1);
        final Sentence sentence = result.getSentence().get(0);
        EObject _ruletype = sentence.getRuletype();
        Assert.assertTrue((_ruletype instanceof ConditionalRuleType));
    }

    @Test
    public void testConditionalRuleDataPropertiesNotAllowed() throws Exception {
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("If Class defines Resource, then it must define equal-to this Resource.");
        _builder.newLine();
        final Model result = this.parseHelper.parse(_builder);
        Assert.assertNotNull(result);
        final EList<Resource.Diagnostic> errors = result.eResource().getErrors();
        StringConcatenation _builder_1 = new StringConcatenation();
        _builder_1.append("Expected errors are not present");
        Assert.assertFalse(_builder_1.toString(), errors.isEmpty());
    }

    @Test
    public void testNegationRule() throws Exception {
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("No LayerBelow can use LayerAbove.");
        _builder.newLine();
        final Model result = this.parseHelper.parse(_builder);
        Assert.assertNotNull(result);
        final EList<Resource.Diagnostic> errors = result.eResource().getErrors();
        StringConcatenation _builder_1 = new StringConcatenation();
        _builder_1.append("Unexpected errors: ");
        String _join = IterableExtensions.join(errors, ", ");
        _builder_1.append(_join);
        Assert.assertTrue(_builder_1.toString(), errors.isEmpty());
        Assert.assertEquals(result.getSentence().size(), 1);
        final Sentence sentence = result.getSentence().get(0);
        EObject _ruletype = sentence.getRuletype();
        Assert.assertTrue((_ruletype instanceof NegationRuleType));
    }

    @Test
    public void testRelativeClauseRule() throws Exception {
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("No Class that (belongsTo FancyComponent) can use UglyPackage.");
        _builder.newLine();
        final Model result = this.parseHelper.parse(_builder);
        Assert.assertNotNull(result);
        final EList<Resource.Diagnostic> errors = result.eResource().getErrors();
        StringConcatenation _builder_1 = new StringConcatenation();
        _builder_1.append("Unexpected errors: ");
        String _join = IterableExtensions.join(errors, ", ");
        _builder_1.append(_join);
        Assert.assertTrue(_builder_1.toString(), errors.isEmpty());
        Assert.assertEquals(result.getSentence().size(), 1);
        final Sentence sentence = result.getSentence().get(0);
        EObject _ruletype = sentence.getRuletype();
        Assert.assertTrue((_ruletype instanceof NegationRuleType));
    }

    @Test
    public void testCardinalityRule() throws Exception {
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("Only a BadClass can import at-least 100 Package.");
        _builder.newLine();
        final Model result = this.parseHelper.parse(_builder);
        Assert.assertNotNull(result);
        final EList<Resource.Diagnostic> errors = result.eResource().getErrors();
        StringConcatenation _builder_1 = new StringConcatenation();
        _builder_1.append("Unexpected errors: ");
        String _join = IterableExtensions.join(errors, ", ");
        _builder_1.append(_join);
        Assert.assertTrue(_builder_1.toString(), errors.isEmpty());
        Assert.assertEquals(result.getSentence().size(), 1);
        final Sentence sentence = result.getSentence().get(0);
        EObject _ruletype = sentence.getRuletype();
        Assert.assertTrue((_ruletype instanceof OnlyCanRuleType));
    }

    @Test
    public void testDataRule() throws Exception {
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("Only a BadClass can haveMethod equal-to 100.");
        _builder.newLine();
        final Model result = this.parseHelper.parse(_builder);
        Assert.assertNotNull(result);
        final EList<Resource.Diagnostic> errors = result.eResource().getErrors();
        StringConcatenation _builder_1 = new StringConcatenation();
        _builder_1.append("Unexpected errors: ");
        String _join = IterableExtensions.join(errors, ", ");
        _builder_1.append(_join);
        Assert.assertTrue(_builder_1.toString(), errors.isEmpty());
        Assert.assertEquals(result.getSentence().size(), 1);
        final Sentence sentence = result.getSentence().get(0);
        EObject _ruletype = sentence.getRuletype();
        Assert.assertTrue((_ruletype instanceof OnlyCanRuleType));
    }

    @Test
    public void testFactConceptAssertion() throws Exception {
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("Fact: FancyClass is a Class .");
        _builder.newLine();
        final Model result = this.parseHelper.parse(_builder);
        Assert.assertNotNull(result);
        final EList<Resource.Diagnostic> errors = result.eResource().getErrors();
        StringConcatenation _builder_1 = new StringConcatenation();
        _builder_1.append("Unexpected errors: ");
        String _join = IterableExtensions.join(errors, ", ");
        _builder_1.append(_join);
        Assert.assertTrue(_builder_1.toString(), errors.isEmpty());
        Assert.assertEquals(result.getSentence().size(), 1);
        final Sentence sentence = result.getSentence().get(0);
        EObject _ruletype = sentence.getRuletype();
        Assert.assertTrue((_ruletype instanceof FactStatement));
    }

    @Test
    public void testFactObjectPropertyAssertion() throws Exception {
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("Fact: FancyClass defines FancyAttribute.");
        _builder.newLine();
        final Model result = this.parseHelper.parse(_builder);
        Assert.assertNotNull(result);
        final EList<Resource.Diagnostic> errors = result.eResource().getErrors();
        StringConcatenation _builder_1 = new StringConcatenation();
        _builder_1.append("Unexpected errors: ");
        String _join = IterableExtensions.join(errors, ", ");
        _builder_1.append(_join);
        Assert.assertTrue(_builder_1.toString(), errors.isEmpty());
        Assert.assertEquals(result.getSentence().size(), 1);
        final Sentence sentence = result.getSentence().get(0);
        EObject _ruletype = sentence.getRuletype();
        Assert.assertTrue((_ruletype instanceof FactStatement));
    }

    @Test
    public void testFactObjectDatatypePropertyAssertionInt() throws Exception {
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("Fact: FancyAttribute hasArrayElements equal-to 42.");
        _builder.newLine();
        final Model result = this.parseHelper.parse(_builder);
        Assert.assertNotNull(result);
        final EList<Resource.Diagnostic> errors = result.eResource().getErrors();
        StringConcatenation _builder_1 = new StringConcatenation();
        _builder_1.append("Unexpected errors: ");
        String _join = IterableExtensions.join(errors, ", ");
        _builder_1.append(_join);
        Assert.assertTrue(_builder_1.toString(), errors.isEmpty());
        Assert.assertEquals(result.getSentence().size(), 1);
        final Sentence sentence = result.getSentence().get(0);
        EObject _ruletype = sentence.getRuletype();
        Assert.assertTrue((_ruletype instanceof FactStatement));
    }

    @Test
    public void testFactObjectDatatypePropertyAssertionString() throws Exception {
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("Fact: FancyAttribute hasName equal-to \"fancyArray\".");
        _builder.newLine();
        final Model result = this.parseHelper.parse(_builder);
        Assert.assertNotNull(result);
        final EList<Resource.Diagnostic> errors = result.eResource().getErrors();
        StringConcatenation _builder_1 = new StringConcatenation();
        _builder_1.append("Unexpected errors: ");
        String _join = IterableExtensions.join(errors, ", ");
        _builder_1.append(_join);
        Assert.assertTrue(_builder_1.toString(), errors.isEmpty());
        Assert.assertEquals(result.getSentence().size(), 1);
        final Sentence sentence = result.getSentence().get(0);
        EObject _ruletype = sentence.getRuletype();
        Assert.assertTrue((_ruletype instanceof FactStatement));
    }
}
