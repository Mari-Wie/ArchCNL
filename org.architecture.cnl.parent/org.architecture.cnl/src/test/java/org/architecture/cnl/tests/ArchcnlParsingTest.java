/** generated by Xtext 2.23.0 */
package org.architecture.cnl.tests;

import com.google.inject.Inject;
import org.architecture.cnl.archcnl.CanOnlyRuleType;
import org.architecture.cnl.archcnl.ConditionalRuleType;
import org.architecture.cnl.archcnl.FactStatement;
import org.architecture.cnl.archcnl.Model;
import org.architecture.cnl.archcnl.MustRuleType;
import org.architecture.cnl.archcnl.NegationRuleType;
import org.architecture.cnl.archcnl.OnlyCanRuleType;
import org.architecture.cnl.archcnl.Sentence;
import org.architecture.cnl.archcnl.SubConceptRuleType;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.testing.InjectWith;
import org.eclipse.xtext.testing.XtextRunner;
import org.eclipse.xtext.testing.util.ParseHelper;
import org.eclipse.xtext.xbase.lib.Exceptions;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.junit.Assert;
import org.junit.Test;
import org.junit.runner.RunWith;

@RunWith(XtextRunner.class)
@InjectWith(ArchcnlInjectorProvider.class)
@SuppressWarnings("all")
public class ArchcnlParsingTest {
    @Inject private ParseHelper<Model> parseHelper;

    @Test
    public void testErrorDetected() {
        try {
            StringConcatenation _builder = new StringConcatenation();
            _builder.append("This is not valid ArchCNL because the syntax is not complied with.");
            _builder.newLine();
            final Model result = this.parseHelper.parse(_builder);
            Assert.assertNull(result);
        } catch (Throwable _e) {
            throw Exceptions.sneakyThrow(_e);
        }
    }

    @Test
    public void testEveryRule() {
        try {
            StringConcatenation _builder = new StringConcatenation();
            _builder.append("Every Observer must observe an Observable.");
            _builder.newLine();
            final Model result = this.parseHelper.parse(_builder);
            Assert.assertNotNull(result);
            final EList<Resource.Diagnostic> errors = result.eResource().getErrors();
            StringConcatenation _builder_1 = new StringConcatenation();
            _builder_1.append("Unexpected errors: ");
            String _join = IterableExtensions.join(errors, ", ");
            _builder_1.append(_join);
            Assert.assertTrue(_builder_1.toString(), errors.isEmpty());
            Assert.assertEquals(result.getSentence().size(), 1);
            final Sentence sentence = result.getSentence().get(0);
            EObject _ruletype = sentence.getRuletype();
            Assert.assertTrue((_ruletype instanceof MustRuleType));
        } catch (Throwable _e) {
            throw Exceptions.sneakyThrow(_e);
        }
    }

    @Test
    public void testEveryMustBeRule() {
        try {
            StringConcatenation _builder = new StringConcatenation();
            _builder.append("Every LayerAbove must be a Layer.");
            _builder.newLine();
            final Model result = this.parseHelper.parse(_builder);
            Assert.assertNotNull(result);
            final EList<Resource.Diagnostic> errors = result.eResource().getErrors();
            StringConcatenation _builder_1 = new StringConcatenation();
            _builder_1.append("Unexpected errors: ");
            String _join = IterableExtensions.join(errors, ", ");
            _builder_1.append(_join);
            Assert.assertTrue(_builder_1.toString(), errors.isEmpty());
            Assert.assertEquals(result.getSentence().size(), 1);
            final Sentence sentence = result.getSentence().get(0);
            EObject _ruletype = sentence.getRuletype();
            Assert.assertTrue((_ruletype instanceof SubConceptRuleType));
        } catch (Throwable _e) {
            throw Exceptions.sneakyThrow(_e);
        }
    }

    @Test
    public void testEveryCanOnlyRule() {
        try {
            StringConcatenation _builder = new StringConcatenation();
            _builder.append("Every LayerBelow can-only import Common.");
            _builder.newLine();
            final Model result = this.parseHelper.parse(_builder);
            Assert.assertNotNull(result);
            final EList<Resource.Diagnostic> errors = result.eResource().getErrors();
            StringConcatenation _builder_1 = new StringConcatenation();
            _builder_1.append("Unexpected errors: ");
            String _join = IterableExtensions.join(errors, ", ");
            _builder_1.append(_join);
            Assert.assertTrue(_builder_1.toString(), errors.isEmpty());
            Assert.assertEquals(result.getSentence().size(), 1);
            final Sentence sentence = result.getSentence().get(0);
            EObject _ruletype = sentence.getRuletype();
            Assert.assertTrue((_ruletype instanceof CanOnlyRuleType));
        } catch (Throwable _e) {
            throw Exceptions.sneakyThrow(_e);
        }
    }

    @Test
    public void testOnlyCanRule() {
        try {
            StringConcatenation _builder = new StringConcatenation();
            _builder.append("Only LayerAbove can use LayerBelow.");
            _builder.newLine();
            final Model result = this.parseHelper.parse(_builder);
            Assert.assertNotNull(result);
            final EList<Resource.Diagnostic> errors = result.eResource().getErrors();
            StringConcatenation _builder_1 = new StringConcatenation();
            _builder_1.append("Unexpected errors: ");
            String _join = IterableExtensions.join(errors, ", ");
            _builder_1.append(_join);
            Assert.assertTrue(_builder_1.toString(), errors.isEmpty());
            Assert.assertEquals(result.getSentence().size(), 1);
            final Sentence sentence = result.getSentence().get(0);
            EObject _ruletype = sentence.getRuletype();
            Assert.assertTrue((_ruletype instanceof OnlyCanRuleType));
        } catch (Throwable _e) {
            throw Exceptions.sneakyThrow(_e);
        }
    }

    @Test
    public void testConditionalRule() {
        try {
            StringConcatenation _builder = new StringConcatenation();
            _builder.append("If Class creates Resource, then it must destroy this Resource.");
            _builder.newLine();
            final Model result = this.parseHelper.parse(_builder);
            Assert.assertNotNull(result);
            final EList<Resource.Diagnostic> errors = result.eResource().getErrors();
            StringConcatenation _builder_1 = new StringConcatenation();
            _builder_1.append("Unexpected errors: ");
            String _join = IterableExtensions.join(errors, ", ");
            _builder_1.append(_join);
            Assert.assertTrue(_builder_1.toString(), errors.isEmpty());
            Assert.assertEquals(result.getSentence().size(), 1);
            final Sentence sentence = result.getSentence().get(0);
            EObject _ruletype = sentence.getRuletype();
            Assert.assertTrue((_ruletype instanceof ConditionalRuleType));
        } catch (Throwable _e) {
            throw Exceptions.sneakyThrow(_e);
        }
    }

    @Test
    public void testConditionalRuleDataPropertiesNotAllowed() {
        try {
            StringConcatenation _builder = new StringConcatenation();
            _builder.append(
                    "If Class defines Resource, then it must define equal-to this Resource.");
            _builder.newLine();
            final Model result = this.parseHelper.parse(_builder);
            Assert.assertNotNull(result);
            final EList<Resource.Diagnostic> errors = result.eResource().getErrors();
            StringConcatenation _builder_1 = new StringConcatenation();
            _builder_1.append("Expected errors are not present");
            Assert.assertFalse(_builder_1.toString(), errors.isEmpty());
        } catch (Throwable _e) {
            throw Exceptions.sneakyThrow(_e);
        }
    }

    @Test
    public void testNegationRule() {
        try {
            StringConcatenation _builder = new StringConcatenation();
            _builder.append("No LayerBelow can use LayerAbove.");
            _builder.newLine();
            final Model result = this.parseHelper.parse(_builder);
            Assert.assertNotNull(result);
            final EList<Resource.Diagnostic> errors = result.eResource().getErrors();
            StringConcatenation _builder_1 = new StringConcatenation();
            _builder_1.append("Unexpected errors: ");
            String _join = IterableExtensions.join(errors, ", ");
            _builder_1.append(_join);
            Assert.assertTrue(_builder_1.toString(), errors.isEmpty());
            Assert.assertEquals(result.getSentence().size(), 1);
            final Sentence sentence = result.getSentence().get(0);
            EObject _ruletype = sentence.getRuletype();
            Assert.assertTrue((_ruletype instanceof NegationRuleType));
        } catch (Throwable _e) {
            throw Exceptions.sneakyThrow(_e);
        }
    }

    @Test
    public void testRelativeClauseRule() {
        try {
            StringConcatenation _builder = new StringConcatenation();
            _builder.append("No Class that (belongsTo FancyComponent) can use UglyPackage.");
            _builder.newLine();
            final Model result = this.parseHelper.parse(_builder);
            Assert.assertNotNull(result);
            final EList<Resource.Diagnostic> errors = result.eResource().getErrors();
            StringConcatenation _builder_1 = new StringConcatenation();
            _builder_1.append("Unexpected errors: ");
            String _join = IterableExtensions.join(errors, ", ");
            _builder_1.append(_join);
            Assert.assertTrue(_builder_1.toString(), errors.isEmpty());
            Assert.assertEquals(result.getSentence().size(), 1);
            final Sentence sentence = result.getSentence().get(0);
            EObject _ruletype = sentence.getRuletype();
            Assert.assertTrue((_ruletype instanceof NegationRuleType));
        } catch (Throwable _e) {
            throw Exceptions.sneakyThrow(_e);
        }
    }

    @Test
    public void testCardinalityRule() {
        try {
            StringConcatenation _builder = new StringConcatenation();
            _builder.append("Only a BadClass can import at-least 100 Package.");
            _builder.newLine();
            final Model result = this.parseHelper.parse(_builder);
            Assert.assertNotNull(result);
            final EList<Resource.Diagnostic> errors = result.eResource().getErrors();
            StringConcatenation _builder_1 = new StringConcatenation();
            _builder_1.append("Unexpected errors: ");
            String _join = IterableExtensions.join(errors, ", ");
            _builder_1.append(_join);
            Assert.assertTrue(_builder_1.toString(), errors.isEmpty());
            Assert.assertEquals(result.getSentence().size(), 1);
            final Sentence sentence = result.getSentence().get(0);
            EObject _ruletype = sentence.getRuletype();
            Assert.assertTrue((_ruletype instanceof OnlyCanRuleType));
        } catch (Throwable _e) {
            throw Exceptions.sneakyThrow(_e);
        }
    }

    @Test
    public void testDataRule() {
        try {
            StringConcatenation _builder = new StringConcatenation();
            _builder.append("Only a BadClass can haveMethod equal-to 100.");
            _builder.newLine();
            final Model result = this.parseHelper.parse(_builder);
            Assert.assertNotNull(result);
            final EList<Resource.Diagnostic> errors = result.eResource().getErrors();
            StringConcatenation _builder_1 = new StringConcatenation();
            _builder_1.append("Unexpected errors: ");
            String _join = IterableExtensions.join(errors, ", ");
            _builder_1.append(_join);
            Assert.assertTrue(_builder_1.toString(), errors.isEmpty());
            Assert.assertEquals(result.getSentence().size(), 1);
            final Sentence sentence = result.getSentence().get(0);
            EObject _ruletype = sentence.getRuletype();
            Assert.assertTrue((_ruletype instanceof OnlyCanRuleType));
        } catch (Throwable _e) {
            throw Exceptions.sneakyThrow(_e);
        }
    }

    @Test
    public void testFactConceptAssertion() {
        try {
            StringConcatenation _builder = new StringConcatenation();
            _builder.append("Fact: FancyClass is a Class .");
            _builder.newLine();
            final Model result = this.parseHelper.parse(_builder);
            Assert.assertNotNull(result);
            final EList<Resource.Diagnostic> errors = result.eResource().getErrors();
            StringConcatenation _builder_1 = new StringConcatenation();
            _builder_1.append("Unexpected errors: ");
            String _join = IterableExtensions.join(errors, ", ");
            _builder_1.append(_join);
            Assert.assertTrue(_builder_1.toString(), errors.isEmpty());
            Assert.assertEquals(result.getSentence().size(), 1);
            final Sentence sentence = result.getSentence().get(0);
            EObject _ruletype = sentence.getRuletype();
            Assert.assertTrue((_ruletype instanceof FactStatement));
        } catch (Throwable _e) {
            throw Exceptions.sneakyThrow(_e);
        }
    }

    @Test
    public void testFactObjectPropertyAssertion() {
        try {
            StringConcatenation _builder = new StringConcatenation();
            _builder.append("Fact: FancyClass defines FancyAttribute.");
            _builder.newLine();
            final Model result = this.parseHelper.parse(_builder);
            Assert.assertNotNull(result);
            final EList<Resource.Diagnostic> errors = result.eResource().getErrors();
            StringConcatenation _builder_1 = new StringConcatenation();
            _builder_1.append("Unexpected errors: ");
            String _join = IterableExtensions.join(errors, ", ");
            _builder_1.append(_join);
            Assert.assertTrue(_builder_1.toString(), errors.isEmpty());
            Assert.assertEquals(result.getSentence().size(), 1);
            final Sentence sentence = result.getSentence().get(0);
            EObject _ruletype = sentence.getRuletype();
            Assert.assertTrue((_ruletype instanceof FactStatement));
        } catch (Throwable _e) {
            throw Exceptions.sneakyThrow(_e);
        }
    }

    @Test
    public void testFactObjectDatatypePropertyAssertionInt() {
        try {
            StringConcatenation _builder = new StringConcatenation();
            _builder.append("Fact: FancyAttribute hasArrayElements equal-to 42.");
            _builder.newLine();
            final Model result = this.parseHelper.parse(_builder);
            Assert.assertNotNull(result);
            final EList<Resource.Diagnostic> errors = result.eResource().getErrors();
            StringConcatenation _builder_1 = new StringConcatenation();
            _builder_1.append("Unexpected errors: ");
            String _join = IterableExtensions.join(errors, ", ");
            _builder_1.append(_join);
            Assert.assertTrue(_builder_1.toString(), errors.isEmpty());
            Assert.assertEquals(result.getSentence().size(), 1);
            final Sentence sentence = result.getSentence().get(0);
            EObject _ruletype = sentence.getRuletype();
            Assert.assertTrue((_ruletype instanceof FactStatement));
        } catch (Throwable _e) {
            throw Exceptions.sneakyThrow(_e);
        }
    }

    @Test
    public void testFactObjectDatatypePropertyAssertionString() {
        try {
            StringConcatenation _builder = new StringConcatenation();
            _builder.append("Fact: FancyAttribute hasName equal-to \"fancyArray\".");
            _builder.newLine();
            final Model result = this.parseHelper.parse(_builder);
            Assert.assertNotNull(result);
            final EList<Resource.Diagnostic> errors = result.eResource().getErrors();
            StringConcatenation _builder_1 = new StringConcatenation();
            _builder_1.append("Unexpected errors: ");
            String _join = IterableExtensions.join(errors, ", ");
            _builder_1.append(_join);
            Assert.assertTrue(_builder_1.toString(), errors.isEmpty());
            Assert.assertEquals(result.getSentence().size(), 1);
            final Sentence sentence = result.getSentence().get(0);
            EObject _ruletype = sentence.getRuletype();
            Assert.assertTrue((_ruletype instanceof FactStatement));
        } catch (Throwable _e) {
            throw Exceptions.sneakyThrow(_e);
        }
    }
}
